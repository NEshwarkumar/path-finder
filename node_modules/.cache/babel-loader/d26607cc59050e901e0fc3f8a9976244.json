{"ast":null,"code":"export function dijkstra(grid, startNode, finishNode) {\n  // Get the grid, the starting node, and the ending node\n  const visitedNodesInOrder = []; // The path traversed in order to reach the finish\n  // Set the distance from start to every other node as infinity\n\n  startNode.distance = 0; // Except for start node which is 0\n\n  const unvisitedNodes = getAllNodes(grid); // Get all Unvisited Nodes\n\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes); // Take two nodes and sort them by their distance\n\n    const closestNode = unvisitedNodes.shift(); // pop off the element from array\n\n    if (closestNode.isWall) continue; // If there's a wall, skip it\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder; // If surrounded by a wall, stop\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode); // Push the nodes in order\n\n    if (closestNode === finishNode) return visitedNodesInOrder; // If the finish node, then return the path\n\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  // Update Neighbour Nodes\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  // get the adjacent nodes that are unvisited\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]); // Top node\n\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // Bottom node\n\n  if (col > 0) neighbors.push(grid[row][col - 1]); // Left node\n\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // Right node\n\n  return neighbors.filter(neighbor => !neighbor.isVisited); // return just the unvisited neighbours\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n} // Backtracks from the finishNode to find the shortest path.\n\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["C:/Users/eshwa/OneDrive/Desktop/Projects/path-finding-visualizer/src/Algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","nodes","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\n  // Get the grid, the starting node, and the ending node\n  const visitedNodesInOrder = []; // The path traversed in order to reach the finish\n  // Set the distance from start to every other node as infinity\n  startNode.distance = 0; // Except for start node which is 0\n  const unvisitedNodes = getAllNodes(grid); // Get all Unvisited Nodes\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes); // Take two nodes and sort them by their distance\n    const closestNode = unvisitedNodes.shift(); // pop off the element from array\n    if (closestNode.isWall) continue; // If there's a wall, skip it\n    if (closestNode.distance === Infinity) return visitedNodesInOrder; // If surrounded by a wall, stop\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode); // Push the nodes in order\n    if (closestNode === finishNode) return visitedNodesInOrder; // If the finish node, then return the path\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  // Update Neighbour Nodes\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  // get the adjacent nodes that are unvisited\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]); // Top node\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // Bottom node\n  if (col > 0) neighbors.push(grid[row][col - 1]); // Left node\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // Right node\n  return neighbors.filter((neighbor) => !neighbor.isVisited); // return just the unvisited neighbours\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}